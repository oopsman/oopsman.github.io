<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>linux-review | 照见自在</title>
  <meta name="author" content="Johnthat">
  
  <meta name="description" content="记录生活点滴">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="linux-review"/>
  <meta property="og:site_name" content="照见自在"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">照见自在</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives/" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories/" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags/" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about/" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> linux-review</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>When Everything Is Ready, Everything May Be Too Late.</p>
<a id="more"></a>
<p>1991年由芬兰人Linus Torvalds开发出Linux操作系统。简而言之，Linux成功的地方主要在于：Minix(Unix), GNU, Internet, POSIX及虚拟团队的产生。</p>
<p>事实上鸟哥认为distributions主要分为两大系统，一种是使用RPM方式安装软件的系统，包括Red Hat, Fedora, SuSE等都是这类；一种则是使用Debian的dpkg方式安装软件的系统，包括Debian, Ubuntu, B2D等等。</p>
<p>Linux操作系统的文件使用目录树系统,与磁盘的对应需要有“挂载”的操作才行。硬盘的规划对于Linux初学者而言，那将是造成你”头疼”的主要凶手之一。因为硬盘的分区技巧需要对于Linux文件结构有相当程度的认知之后才能够做出比较完善的规划的。</p>
<p>能不能进入某一个目录，只与该目录的x权限有关。要开放目录给任何人浏览时，应该至少也要给予r及x的权限，但w权限不可随便给。</p>
<p>为什么每套Linux distributions他们的配置文件、执行文件、每个目录内放置的内容其实都差不多？原来是有一套标准依据的！因为利用Linux来开发产品或distributions的团队/公司与个人实在太多了，如果每个人都用自己的想法来配置文件放置的目录，那么将可能造成很多管理上的困扰。你能想象，你进入一个企业之后，所接触到的Linux目录配置方法竟然跟你以前学的完全不同吗？很难想象吧～所以，后来就有所谓的Filesystem Hierarchy Standard (FHS)标准的出炉了！<br>/srv：srv可以视为”service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。常见的服务例如WWW、FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。<br>/usr：很多读者都会误会/usr为user的缩写，其实usr是Unix Software Resource的缩写，也就是“Unix操作系统软件资源”所放置的目录，而不是用户的数据！所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows系统的”C:\Windows\ + C:\Program files\”这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。</p>
<p>-：代表前一个工作目录。默认条件中,cp的源文件与目的文件的权限是不同的,目的文件的所有者通常会是命令操作者本身。若备份文件，可使用-a参数来完整复制文件的权限。(权限与命令间的关系!)<br>linux中带.d的目录：.d是directory的缩写，表示这是一个目录（文件夹）。这个在配置文件中比较常见，一般如果有一系列格式相同的，目的一致的配置文件，就把它们放在一个以.d结尾的文件夹中。例如，init.d中存放的就是一系列系统服务的管理（启动与停止）脚本。</p>
<p>在Linux底下也有相当优异的搜寻命令！find不很常用的！因为速度慢之外，也很耗硬盘！通常我们都是先使用whereis或者是locate来检查，如果真的找不到了，才以find来搜寻。</p>
<p>vi是“Visual”的不正规的缩写，来源于另外一个文本编辑器ex的命令visual。Vim（Vi IMproved）是一种升级版。小数点“.”为重复进行前一次动作,也是经常使用的按键功能!</p>
<p>Linux使用的是哪一个shell呢?什么!哪一个?难道说shell不就是”一个shell”吗?哈哈!那可不!由于早年的Unix年代,发展者众,所以由于shell依据发展者的不同就有许多的版本,例如常听到的Bourne SHell(sh)、在Sun里头预设的C SHell、商业上常用的K SHell、还有TCSH等等,每一种Shell都各有其特点。bash是Bourne Shell的增强版本,Linux默认就是使用bash。<br>bash的主要优点：1、命令记忆能力 2、命令与文件补全功能 3、命令别名(alias) 4、工作控制(jobs)：可以让我们随时将工作丢到后台中执行!而不怕不小心使用了Ctrl+c来中断该进程!此外也可以在单一登入的环境中达到多任务的目的呢!<br>通过type这个命令我们可以知道每个命令是否为bash的内置命令。</p>
<p>shell的变量：1、显示时变量前必须加$或者${变量}  2、设置的时候等号前后不允许有空格 3、取消变量：unset 变量名称 4、若变量需要在其他子进程执行，则需要以export来使变量成为环境变量 5、双引号内的特殊字符保有原有特性、单引号内的特殊字符仅为一般字符(纯文本) 6、通过其他命令提供信息赋值可使用反单引号`命令`或$(命令) </p>
<p>什么是“子进程”呢？就是说在我目前这个shell的情况下，去打开另一个新的shell，新的那个shell就是子进程。在一般的情况下，父进程的自定义变量是无法在子进程内使用的。但是通过export将变量变成环境变量后，就能够在子进程下面应用了。(打开新shell使用命令bash) </p>
<p>bash可不只有环境变量，还有一些与bash操作接口有关的变量，以及用户自己定义的变量存在的。那么这些变量如何查看呢？这个时候就得要使用set这个命令了。<br>问号也是一个特殊的变量，在bash里面这个变量很重要。一般来说，如果成功的运行该命令，则会回传一个0值，如果运行过程发生错误，就会回传”错误代码”才对！<br>export：自定义变量转成环境变量，若环境变量转成自定义变量：declare +x 变量名<br>变量的键盘读取：read，变量的声明declare(数组、整型、环境变量…)。变量类型默认为字符串。</p>
<p>命令查找的顺序，可通过type -a查询得到。查找顺序为：1、以相对/绝对路径执行命令，例如”/bin/ls”或”./ls” 2、由alias找到该命令来执行 3、由bash内建的(builtin)命令来执行 4、通过$PATH这个变量的顺序找到的第一个命令来执行。</p>
<p>你是否会觉得奇怪，怎么我们什么动作都没有进行，但是一进入bash就取得一堆有用的变量了？这是因为系统有一些环境配置文件的存在，让bash在启动时直接读取这些配置文件，以规划好bash的操作环境！而这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件。<br>bash的配置文件主要分为login shell与non-login shell。login shell主要读取/etc/profile与~/.bash_profile，non-login shell则仅读取~/.bashrc。</p>
<p>连续命令的执行可通过 ;、&amp;&amp;、||符号来处理。</p>
<p>我们Linux系统的服务(services)启动的接口，在/etc/init.d/这个目录下，目录下所有的文件都是shell script；另外包括开机(booting)过程也都是利用shell script来帮忙查找系统的相关设置数据，然后再代入各个服务的设置参数！<br>shell script如何运行？1、直接命令执行(shell.sh文件必须要具备可读与可执行(rx)的权限) 2、以bash进程来执行(通过“bash shell.sh”或“sh shell.sh”来运行，此时你的shell.sh只要有r的权限即可被执行) 3、source或小数点<br>上述执行方式的区别：1.利用直接执行的方式来执行script，使用这种执行方式时，其实script是在子进程的bash内执行的！ 2、利用source来执行脚本：在父进程中执行。 这也是为啥你不注销系统而要让某些写入~/.bashrc的配置生效时，需要使用”source ~/.bashrc”而不能使用”bash ~/.bashrc”。<br>shell script利用exit n(n是数字)的功能，回传一个数值给系统，告知执行结果。<br>判断符号中括号[]的使用方法与test几乎一模一样。只是中括号比较常用在条件判断式if…then…fi的情况中就是了。使用中括号需要注意：1、在中括号[]内的每个组件都需要有空格键来分隔 2、在中括号内的变量，最好都以双引号括号起来 3、在中括号内的常数，最好都以单或双引号括号起来。<br>shell script的默认变量：$0, $1，$#..<br>shell script的追踪和调试可通过bash命令的参数：-n:不执行script，仅检查是否有语法问题  2、-x : 将使用到的script打印出来。</p>
<p>文件如何判别它的所有者与用户组呢?其实就是利用UID与GID。每一个文件都会有所谓的所有者ID与用户组ID,当我们有要显示文件属性的需求时,系统会根据/etc/passwd与/etc/group的内容,找到UID/GID对应的账号与组名再显示出来。<br>你输入账号密码后，系统帮你处理了什么呢？1、先找寻/etc/passwd 里面是否有你输入的账号，如果没有则跳出，如果有的话则将该账号对应的UID与GID（在/etc/group 中）读出来，另外，该账号的主文件夹与shell 设置也一并读出。 2、再来则是核对密码表。Linux会进入/etc/shadow 里面找出对应的账号与UID，然后核对一下你刚才输入的密码与里面的密码是否相符。 3、如果一切ok的话，就进入shell控管的阶段了。<br>当UID是0时，代表这个账号是系统管理员！所以当你要让其他的账号名称也具有root的权限时，将该账号的UID改为0即可。这也就是说，一部系统上面的系统管理员不见得只有root！不过，不建议有多个账号的UID是0。 </p>
<p>刚刚我们讲到了，使用useradd建立了账号之后，在默认的情况下，该账号是暂时被封锁的，也就是说，该账号是无法登录的，你可以去瞧一瞧/etc/shadow内的第二个字段就知道了。那该如何是好？怕什么？直接给他设置新密码就好了！对吧～设置密码就使用passwd！(root可以帮忙设置各式各样的密码，系统几乎一定会接受!) </p>
<p>用户身份切换—如何让一般用户转变身份成为root呢？主要有两种方式：<br>1、以”su -“直接将身份变成root即可，但是这个命令却需要root的密码，也就是说，如果你要以su变成root的话，你的一般用户就必须要有root的密码才行；(-代表使用login-shell的变量文件读取方式来登陆系统、使用exit退出身份、使用root切换成为任何用户时，并不需要输入新用户的密码)<br>2、以”sudo 命令”执行root的命令串，由于sudo需要事先设置妥当，且sudo需要输入用户自己的密码，因此多人共管同一部主机时，sudo要比su来的好！至少root密码不会流出去！(并非所有人都能够运行sudo，而是仅有/etc/sudoers内的用户才能够执行sudo这个命令、除了root之外的其他账号，若想要使用sudo执行属于root的权限命令，则root需要先使用visudo去修改/etc/sudoers，让该账号能够使用全部或部分的root命令功能、sudo搭配su的使用方式：只要输入”sudo su -“并且输入自己的密码后，立刻变成root的身份！不但root密码不会外泄，用户的管理也变的非常方便！)</p>
<p>用户的特殊shell：/sbin/nologin是一个特殊的shell,如果一个账号的shell是/sbin/nologin,那么它是无法通过shell登录的，但是它可以使用系统的资源，这样就限制了这个账号使用shell的权利。因为有些账号是不需要使用shell的，分给它们会让系统陷入危险。</p>
<p>Linux工作排调度的种类：at、cron。<br>at：是个可以处理仅执行一次就结束调度的命令，不过要执行at时，必须要有atd这个服务的支持才行。CentOS默认是启动的。(事实上，当我们使用at时会进入一个at shell的环境来让用户执行任务命令，ctrl+D结束、我们可以利用/etc/at.allow与/etc/at.deny这两个文件来进行at的使用限制)<br>cron：这个这个命令所完成的工作将会循环一直进行下去！crontab除了可以使用命令执行外，亦可编辑/etc/crontab来支持。而让crontab可以生效的服务是crond这个服务！(与at类似的使用限制，/etc/cron.allow优先级比/etc/cron.deny要高、crontab -e是针对用户的cron来设计的(会被记录到/var/spool/cron/)，如果是系统的例行性任务时，只需要编辑/etc/crontab这个文件就可以、/n(斜线)即是“每隔n单位间隔”的意思、cron执行的每一项工作都会被记录到/var/log/cron这个日志文件中)<br>基本上，cron这个服务的最低检测限制是”分钟”，所以cron会每分钟去读取一次/etc/crontab与/var/spool/cron里面的数据内容，因此，只要你编辑完/etc/crontab这个文件，并且将它保存之后，那么cron的设定就自动会来执行了！<br>anacron(可唤醒停机期间的工作任务)并不是用来取代crontab的，anacron存在的目的就在于我们上头提到的，处理非24小时一直启动的Linux系统的crontab的执行！anacron其实是一个程序并非一个服务！</p>
<p>现在你知道系统是如何进行它默认的一堆例行性工作调度了吗？如果你执行”ll /etc/cron.daily”就可以看到一堆文件，那些文件就是系统提供的script，而这堆scripts将会在每天的凌晨4:02开始运行！这也是为啥如果你是夜猫族，就会发现奇怪的是，Linux系统为何早上4:02开始会很忙碌的发出一些硬盘跑动的声音！因为它必须要进行makewhatis、updatedb、rpm rebuild等等的任务！</p>
<p>在Linux系统当中：触发任何一个事件时，系统都会将他定义成为一个进程，并且给予这个进程一个ID，称为PID，同时依据触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置。从此以后，这个PID能够在系统上面进行的操作，就与这个PID的权限有关了！<br>每个进程都有一个PID，那某个进程的父进程该如何判断？就通过Parent PID(PPID)来判断即可。<br>常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户各项任务，因此这些常驻进程就会被我们称为服务(daemon)。</p>
<p>工作管理(job control)：这个工作管理(job control)是用在bash环境下的。在进行工作管理的行为中，其实每个工作都是目前bash的子进程。放入后台的工作是不可以使用ctrl+c来终止的，可使用bg/fg调用该工作。<br>在后台里面的工作状态又可分为暂停(stop)与运行中(running)。实际进行job控制的命令有哪些？1、直接将命令丢到后台中执行的&amp; 2、将目前的工作丢到后台中暂停ctrl+z，查看目前的后台工作状态:jobs 3、将后台的工作拿到前台来处理:fg %jobnumber 4、让工作在后台下的状态变成运行中:bg %jobnumber 5、管理后台当中的工作:kill -single %jobnumber(kill后面接的数字默认会是PID，若想管理bash下的工作，就得要加上%数字)<br>特别留意一下，-9这个signal通常是用在强制删除一个不正常的工作时所使用的，-15则是以正常步骤结束一项工作(15也是默认值)，两者之间并不相同！举例来说，我用vi的时候，不是会产生一个.filename.swp的文件吗？那么，当使用-15这个signal时，vi会尝试以正常的步骤来结束掉该vi的工作，所以.filename.swp会主动的被移除，但若是使用-9这个signal时，由于该vi工作会被强制移除掉，因此.filename.swp就会继续存在文件系统当中。</p>
<p>如果你是以远程连线方式连接到你的Linux主机，并且将工作以&amp;的方式放到后台去，请问，在工作尚未结束的情况下你脱机了，该工作还会继续进行吗？答案是“否”！不会继续进行，而是会被中断掉！那怎么办？<br>nohup可以让你在脱机或注销系统后，还能够让工作继续进行。nohup并不支持bash内置的命令，因此你的命令必须要是外部命令才行。nohup与终端机其实无关了，故信息的输出就会被定向到nohup.out。(nohup [命令与参数] &lt;==在终端机前台中工作、nohup [命令与参数] &amp; &lt;==在终端机后台中工作) </p>
<p>进程的查看：1、ps:将某个时间点的进程运行情况选取下来(进程树) 2、top:动态查看进程的变化(排序、k给某个PID一个信号、r给摸个PID一个nice值)<br>我们知道CPU一秒钟可以运作多达数G的微命令次数，通过内核的CPU调度可以让各进程被CPU所切换运行，因此每个进程在一秒钟内或多或少都会被CPU执行部分的脚本。(如果优先级较高则运行次数可以较多次)</p>
<p>系统为了某些功能必须要提供一些服务(不论是系统本身还是网络方面)，这个服务就称为service。但是service的提供总是需要进程的运行！否则如何执行呢？所以实现这个service的进程我们就称它为daemon！</p>
<p>服务(daemon)主要可以分为stand alone(服务可单独启动)及super daemon(通过xinetd统一管理的服务，其常驻内存)两种。<br>stand alone的daemon响应速度较快。常见的stand alone daemon有www的daemon(httpd)、FTP的daemon(vsftpd)等。<br>super daemon当没有客户端的要求时，各项服务都是未启动的情况，等到有来自客户端的要求时，super daemon才唤醒相对应的服务。当客户端的要求结束后，被唤醒的这个服务也会关闭并释放系统资源。常见的super daemon所管理的服务例如telnet这个就是。</p>
<p>几乎系统上面所有服务的启动脚本都在/etc/init.d/下面，这里面的脚本会去检测环境、查找配置文件、 加载distribution提供的函数功能、判断环境是否可以运行此daemon等等，等到一切都检测完毕且确定可以运行后，再以shell script的case….esac语法来启动、关闭、查看此daemon。<br>stand alone daemon的启动方法也可以使用service这个命令，service仅是一个script，它可以分析你执行的service后面的参数，然后根据你的参数再到/etc/init.d/去取得正确的服务来start或stop！</p>
<p>super daemon的主要配置文件(其实是默认值)为/etc/xinetd.conf，不过我们上面就谈到了，super daemon只是一个统一管理的机制，他所管理的其他daemon的配置则写在/etc/xinetd.d/<em>里面！<br>Super daemon本身也是一个stand alone的服务，所以Super daemon自己启动的方式与stand alone是相同的！但是他所管理的其他daemon就不是这样做了！必须要在配置文件中配置为启动该daemon才行。配置文件就是/etc/xinetd.d/</em>的所有文件。默认所有的super daemon管理的服务都不启动的。 </p>
<p>Linux主机是怎么启动的呢？1、打开计算机电源，开始读取BIOS并进行主机的自我测试；2、通过BIOS取得第一个可开机设备，读取主要启动区(MBR)取得启动装载程序；3、通过启动装载程序的配置，取得kernel并加载内存且检测系统硬件；4、内核主动调用init进程；5、init进程开始执行系统初始化(/etc/rc.d/rc.sysinit)；6、依据init的设置进行daemon start(/etc/rc.d/rc[0-6].d/*)；7、加载本机配置(/etc/rc.d/rc.local)；事实上第六个步骤就是以不同的执行等级调用不同的服务！(不同的执行等级有不同的功能与服务)</p>
<p>管理系统服务默认开机启动与否：chkconfig。chkconfig –list [服务名称]、chkconfig [–level [0123456]] [服务名称] [on|off]。chkconfig仅是设置开机时默认会启动的服务而已，所以该服务目前的状态如何是不知道的。<br>chkconfig [–add|–del] [服务名称] 选项与参数：–add：添加一个服务名称给chkconfig来管理，该服务名称必须在/etc/init.d/内；–del：删除一个给chkconfig管理的服务。<br>如果我自己写了一个程序并且想要让该程序成为系统服务好让chkconfig来管理时，可以怎么进行呢？只要将该服务加入init可以管理的script当中，亦即是/etc/init.d/当中即可。编写脚本的第二行比较重要，语法：chkconfig: [runlevels] [启动顺位] [停止顺位] 其中，runlevels为不同的run level状态，启动顺位(start number)与结束顺位(stop number)则是在/etc/rc.d/rc[35].d内创建以S80myvbird及K70myvbird为文件名的设置方式！<br>格式：#!/bin/sh   #chkconfig: 2345 80 90   #description:auto_run   前两行必不可少哦！ </p>
<p>Linux常见的日志文件名(日志文件的权限通常是设置为仅有root能够读取而已)：<br>1、/var/log/cron—用来记录crontab这个服务的内容<br>2、/var/log/dmesg—记录系统在开机的时候内核检测过程所产生的各项信息<br>3、/var/log/lastlog—记录系统上面的所有账号最近一次登录系统时的相关信息<br>4、/var/log/messages—记录几乎所有系统错误或者重要的信息<br>5、/var/log/secure—基本上，只要牵涉到需要输入账号密码的软件，那么当登录时(不管登录正确或错误)都会被记录在此文件中<br>6、/var/log/httpd/*—不同的网络服务会使用它们自己的日志文件来记载它们自己产生的各项信息</p>
<p>那么这些日志文件是怎么产生的呢？基本上有两种方式：一种是由软件开发商自行定义写入的日志文件与相关格式，例如WWW软件apache就是这样处理的。另一种则是由Linux distribution提供的日志文件管理服务来统一管理。你只要将信息丢给这个服务后，他就会自己分门别类的将各种信息放置到相关的日志文件去！CentOS提供syslogd这个服务来统一管理日志文件！<br>如果你任凭日志文件持续记录的话，由于系统产生的信息天天都有，那么你的日志文件的容量将会无限增大，我们可以通过logrotate(日志轮替)命令来自动化处理日志文件容量与更新。</p>
<p>logrotate程序利用crontab来进行日志文件的轮替功能；logrotate的配置文件为/etc/logrotate.conf，而额外的设置则可写入/etc/logrotate.d/*内。</p>
<p>在Linux系统上面，一个文件能不能被执行看的是有没有可执行的那个权限(具有x)，不过Linux系统上真正认识的可执行文件其实是二进制文件。例如：/usr/bin/passwd、/bin/touch。(可以通过file filename命令来查看某一个文件是否是可执行文件、函式库:就类似子程序的角色，可以被调用来执行的一段功能函数)<br>所谓的Tarball文件，其实就是将软件的所有原始码文件先以tar打包，然后再以压缩技术来压缩，tarball文件一般的扩展名就会写成.tar.gz或者是简写为.tgz。Tarball是一个软件包，你将他解压缩之后，里面的文件通常就会有:1、源代码文件 2、检测程序文件(configure或config) 3、本软件的简易说明与安装说明(README/INSTALL)</p>
<p>直接源码的方式虽然具有很高的弹性，但毕竟麻烦一点。如果Linux distribution厂商能够针对自己的系统平台进行编译等过程，再将编译好的二进制程序放出的话，由于环境是相同的，那就可以直接在我的电脑上面安装，省去复杂编译的过程。预先编译好的程序的机制存在于很多distribution，包括Red Hat系统发展的RPM软件管理机制与yum在线更新模式。Debian使用的dpkg软件管理机制与apt在线更新模式。<br>make是一个程序，make的功能是可以简化编译过程里面所执行的命令。(检测程序configure/config检查完毕后就会主动新建makefile的规则文件)<br>当makefile在创建出来之后，里面会有相当多的目标(target)，最常见的就是install与clean。通常“make clean”表示将目标文件清除掉，“make”是将源码进行编译。注意，编译完成的可执行文件与相关的配置文件还在源码所在的目录当中，因些，最后要进行“make install”将编译完成的所有内容都安装到正确的路径中，这样就可以使用该软件了！(安装软件涉及的目录大致有：可执行目录bin、用到的函数库目录lib、配置文件目录etc、帮助文档目录man)<br>为什么Tarball要在/usr/local/src里面解压缩呢？基本上，在默认的情况下，原本的Linux distribution发布安装的软件大多是在/usr里面的，而用户自行安装的软件则建议放置在/usr/local里面。这是考虑到管理用户所安装软件的便利性。<br>tarball这种方式的软件升级或更新，利用patch，patch的主要功能是更新源码，所以更新源码之后，还需要进行重新编译的操作才行。<br>一般来说configure设置参数较重要的就是那个–prefix=/path了，–prefix后面接的路径就是“这个软件未来要安装到那个目录去”。如果你没有指定–prefix=/path这个参数，通常默认参数就是/usr/local。 </p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2018/03/10/Free-Software-Song/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2018/03/03/Reading-Plan/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2018-03-06 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 Johnthat
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
